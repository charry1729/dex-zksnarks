import "./isPartialOrder.code"
import "./decodeOrder.code"
import "./emptyOrder.code"


def zeroTupleForTokens():
  return 0, 0, 0

def priceFromTo(sourceToken, targetToken, priceToken1, priceToken2):
  refTokenPriceToUtxo = if sourceToken == 0 then 1000000000000000000 else 0 fi
  refTokenPriceToUtxo = refTokenPriceToUtxo + if sourceToken == 1 then priceToken1 else 0 fi
  refTokenPriceToUtxo = refTokenPriceToUtxo + if sourceToken == 2 then priceToken2 else 0 fi

  refTokenPriceToTarget = if targetToken == 0 then 1000000000000000000 else 0 fi
  refTokenPriceToTarget = refTokenPriceToTarget + if targetToken == 1 then priceToken1 else 0 fi
  refTokenPriceToTarget = refTokenPriceToTarget + if targetToken == 2 then priceToken2 else 0 fi
  return 1000000000000000000 * (refTokenPriceToTarget/refTokenPriceToUtxo)

def limitLessThanPrice(sourceToken, targetToken, limit, priceToken1, priceToken2):
  // Assuming limit is in sourceToken->targetToken and price_i in refToken->token_i
  // Because of arbitrage freeness the following statement should hold:
  // sourceToken->targetToken = sourceToken->refToken * refToken->targetToken = refToken->targetToken / refToken->sourceToken
  // Therefore we have to check that:
  // limit <= refToken->targetToken / refToken->sourceToken <==> refToken->targetToken / refToken->sourceToken > limit
  limitIsLessOrEqual = if priceFromTo(sourceToken, targetToken, priceToken1, priceToken2) < limit then 0 else 1 fi
  return limitIsLessOrEqual

def addSellVolumesForOrder(sellVolumeToken1, sellVolumeToken2, sellVolumeToken3, sourceToken, volume):
  updatedVolumeToken1 = sellVolumeToken1 + if sourceToken == 0 then volume else 0 fi
  updatedVolumeToken2 = sellVolumeToken2 + if sourceToken == 1 then volume else 0 fi
  updatedVolumeToken3 = sellVolumeToken3 + if sourceToken == 2 then volume else 0 fi
  return updatedVolumeToken1, updatedVolumeToken2, updatedVolumeToken3

def addBuyVolumesForOrder(buyVolumeToken1, buyVolumeToken2, buyVolumeToken3, sourceToken, volume, targetToken, priceToken1, priceToken2):
  buyVolume = volume * priceFromTo(sourceToken, targetToken, priceToken1, priceToken2) / 1000000000000000000 
  txBuyVolumeToken1 = buyVolumeToken1 + if targetToken == 0 then buyVolume else 0 fi
  txBuyVolumeToken2 = buyVolumeToken2 + if targetToken == 1 then buyVolume else 0 fi
  txBuyVolumeToken3 = buyVolumeToken3 + if targetToken == 2 then buyVolume else 0 fi
  return txBuyVolumeToken1, txBuyVolumeToken2, txBuyVolumeToken3

def checkPartialLimitForOrder(lowestPartialLimitPriceToken1, lowestPartialLimitPriceToken2, lowestPartialLimitPriceToken3, utxoAmount, sourceToken, limit, volume):
  // if this is a partial order we need to have either no lowestPartialOrder for this token yet, or one at the same price
  updatedPartialLimitPriceToken1 = if sourceToken == 0 then if isPartialOrder(utxoAmount, volume) == 1 then limit else lowestPartialLimitPriceToken1 fi else lowestPartialLimitPriceToken1 fi
  updatedPartialLimitPriceToken2 = if sourceToken == 1 then if isPartialOrder(utxoAmount, volume) == 1 then limit else lowestPartialLimitPriceToken2 fi else lowestPartialLimitPriceToken2 fi
  updatedPartialLimitPriceToken3 = if sourceToken == 2 then if isPartialOrder(utxoAmount, volume) == 1 then limit else lowestPartialLimitPriceToken3 fi else lowestPartialLimitPriceToken3 fi

  // If updatedPartialLimitPriceTokenPrice != lowestPartialLimitPriceTokenPrice, lowestPartialLimitPriceTokenPrice must have been 0 before
  invalid = if lowestPartialLimitPriceToken1 - updatedPartialLimitPriceToken1 == 0 then 0 else lowestPartialLimitPriceToken1 fi
  invalid == 0
  invalid = if lowestPartialLimitPriceToken2 - updatedPartialLimitPriceToken2 == 0 then 0 else lowestPartialLimitPriceToken2 fi
  invalid == 0
  invalid = if lowestPartialLimitPriceToken3 - updatedPartialLimitPriceToken3 == 0 then 0 else lowestPartialLimitPriceToken3 fi
  invalid == 0

  return updatedPartialLimitPriceToken1, updatedPartialLimitPriceToken2, updatedPartialLimitPriceToken3

def checkConstraints(amount1, sourceToken1, targetToken1, limit1, amount2, sourceToken2, targetToken2, limit2, amount3, sourceToken3, targetToken3, limit3, volume1, volume2, volume3, priceToken1, priceToken2):
  // orders are only touched, if the limit price is below the calculated price:
  valid = if volume1 == 0 then 1 else limitLessThanPrice(sourceToken1, targetToken1, limit1, priceToken1, priceToken2) fi
  valid == 1
  valid = if volume2 == 0 then 1 else limitLessThanPrice(sourceToken2, targetToken2, limit2, priceToken1, priceToken2) fi
  valid == 1
  valid = if volume3 == 0 then 1 else limitLessThanPrice(sourceToken3, targetToken3, limit3, priceToken1, priceToken2) fi
  valid == 1

  // the amount of sell volume for a token equals its buy volume:
  buyVolumeToken1, buyVolumeToken2, buyVolumeToken3 = zeroTupleForTokens()
  sellVolumeToken1, sellVolumeToken2, sellVolumeToken3 = zeroTupleForTokens()

  buyVolumeToken1, buyVolumeToken2, buyVolumeToken3 = addBuyVolumesForOrder(buyVolumeToken1, buyVolumeToken2, buyVolumeToken3, sourceToken1, volume1, targetToken1, priceToken1, priceToken2)
  sellVolumeToken1, sellVolumeToken2, sellVolumeToken3 = addSellVolumesForOrder(sellVolumeToken1, sellVolumeToken2, sellVolumeToken3, sourceToken1, volume1)

  buyVolumeToken1, buyVolumeToken2, buyVolumeToken3 = addBuyVolumesForOrder(buyVolumeToken1, buyVolumeToken2, buyVolumeToken3, sourceToken2, volume2, targetToken2, priceToken1, priceToken2)
  sellVolumeToken1, sellVolumeToken2, sellVolumeToken3 = addSellVolumesForOrder(sellVolumeToken1, sellVolumeToken2, sellVolumeToken3, sourceToken2, volume2)

  buyVolumeToken1, buyVolumeToken2, buyVolumeToken3 = addBuyVolumesForOrder(buyVolumeToken1, buyVolumeToken2, buyVolumeToken3, sourceToken3, volume3, targetToken3, priceToken1, priceToken2)
  sellVolumeToken1, sellVolumeToken2, sellVolumeToken3 = addSellVolumesForOrder(sellVolumeToken1, sellVolumeToken2, sellVolumeToken3, sourceToken3, volume3)

  buyVolumeToken1 == sellVolumeToken1
  buyVolumeToken2 == sellVolumeToken2
  buyVolumeToken3 == sellVolumeToken3

  // If an order σ ∈ Oi→j with a limit price p has a positive trading volume, then every order in Oi→j with a lower limit price should be completely fulfilled.
  lowestPartialLimitPriceToken1, lowestPartialLimitPriceToken2, lowestPartialLimitPriceToken3 = zeroTupleForTokens()
  lowestPartialLimitPriceToken1, lowestPartialLimitPriceToken2, lowestPartialLimitPriceToken3 = checkPartialLimitForOrder(lowestPartialLimitPriceToken1, lowestPartialLimitPriceToken2, lowestPartialLimitPriceToken3, amount1, sourceToken1, limit1, volume1)
  lowestPartialLimitPriceToken1, lowestPartialLimitPriceToken2, lowestPartialLimitPriceToken3 = checkPartialLimitForOrder(lowestPartialLimitPriceToken1, lowestPartialLimitPriceToken2, lowestPartialLimitPriceToken3, amount2, sourceToken2, limit2, volume2)
  lowestPartialLimitPriceToken1, lowestPartialLimitPriceToken2, lowestPartialLimitPriceToken3 = checkPartialLimitForOrder(lowestPartialLimitPriceToken1, lowestPartialLimitPriceToken2, lowestPartialLimitPriceToken3, amount3, sourceToken3, limit3, volume3)

  return 1 // Could return total volume to maximize for

def main(encodedOrder1, encodedOrder2, encodedOrder3, bitmapOrder1, bitmapOrder2, bitmapOrder3, volume1, volume2, volume3, priceToken1, priceToken2):
  // Remove orders that are not double signed
  encodedOrder1 = if bitmapOrder1 == 1 then encodedOrder1 else 0 fi
  encodedOrder2 = if bitmapOrder2 == 1 then encodedOrder2 else 0 fi
  encodedOrder3 = if bitmapOrder3 == 1 then encodedOrder3 else 0 fi

  // Decode orders
  amount1, sourceToken1, targetToken1, limit1 = decodeOrder(encodedOrder1)
  amount2, sourceToken2, targetToken2, limit2 = decodeOrder(encodedOrder2)
  amount3, sourceToken3, targetToken3, limit3 = decodeOrder(encodedOrder3)

  return checkConstraints(amount1, sourceToken1, targetToken1, limit1, amount2, sourceToken2, targetToken2, limit2, amount3, sourceToken3, targetToken3, limit3, volume1, volume2, volume3, priceToken1, priceToken2)
import "./decodeOrderBitwise.code"

<% const volumes = generateVariableNames('volume', orders) -%>
<% const prices = generateVariableNames('priceToken', tokens-1) -%>
<% const decodedOrderTuples = generateDecodedOrderTuples(orders) -%>

def tupleForTokensWithValue(value):
  return <%= generateVariableNames('', tokens).map(function(i) {return 'value'}).join(', ') %>

def tupleForTokenPairsWithValue(value):
  return <%= generateTokenPairs('', tokens).map(function(i) {return 'value'}).join(', ') %>

<% const pairs = generateTokenPairs('pair', tokens) -%>
def findPairInTokenPairList(<%= pairs.map(function(pair) {return pair.name}).join(', ') %>, sourceToken, targetToken):
  pair = 0
  <%_ for(var i=0; i < pairs.length; i++) { _%>
  <%_ let pair = pairs[i]; _%>
  pair = if sourceToken == <%= pair.source %> then if targetToken == <%= pair.target %> then <%= pair.name %> else pair fi else pair fi
  <%_ } _%>
  return pair

def priceFromTo(sourceToken, targetToken, <%- prices.join(", ") %>):
  refTokenPriceToUtxo = if sourceToken == 0 then 1000000000000000000 else 0 fi
  <%_ for(var i=0; i < prices.length; i++) { _%>
  refTokenPriceToUtxo = refTokenPriceToUtxo + if sourceToken == <%= i+1 %> then <%= prices[i] %> else 0 fi
  <%_ } _%>

  refTokenPriceToTarget = if targetToken == 0 then 1000000000000000000 else 0 fi
  <%_ for(var i=0; i < prices.length; i++) { _%>
  refTokenPriceToTarget = refTokenPriceToTarget + if targetToken == <%= i+1 %> then <%= prices[i] %> else 0 fi
  <%_ } _%>

  return 1000000000000000000 * (refTokenPriceToTarget/refTokenPriceToUtxo)

def limitLessThanPrice(sourceToken, targetToken, limit, <%- prices.join(", ") %>):
  // Assuming limit is in sourceToken->targetToken and price_i in refToken->token_i
  // Because of arbitrage freeness the following statement should hold:
  // sourceToken->targetToken = sourceToken->refToken * refToken->targetToken = refToken->targetToken / refToken->sourceToken
  // Therefore we have to check that:
  // limit <= refToken->targetToken / refToken->sourceToken <==> refToken->targetToken / refToken->sourceToken > limit
  limitIsLessOrEqual = if priceFromTo(sourceToken, targetToken, <%- prices.join(", ") %>) < limit then 0 else 1 fi
  return limitIsLessOrEqual

<% const updatedVolumeToken = generateVariableNames('updatedVolumeToken', tokens) -%>
<% const sellVolumeToken = generateVariableNames('sellVolumeToken', tokens) -%>
def addSellVolumesForOrder(<%- sellVolumeToken.join(", ") %>, sourceToken, volume):
  <%_ for(var i=0; i < updatedVolumeToken.length; i++) { _%>
  <%= updatedVolumeToken[i] %> = <%= sellVolumeToken[i] %> + if sourceToken == <%= i %> then volume else 0 fi
  <%_ } _%>
  return <%- updatedVolumeToken.join(", ") %>

<% const txBuyVolumeToken = generateVariableNames('txBuyVolumeToken', tokens) -%>
<% const buyVolumeToken = generateVariableNames('buyVolumeToken', tokens) -%>
def addBuyVolumesForOrder(<%- buyVolumeToken.join(", ") %>, sourceToken, volume, targetToken, <%- prices.join(", ") %>):
  buyVolume = volume * priceFromTo(sourceToken, targetToken, <%- prices.join(", ") %>) / 1000000000000000000 
  <%_ for(var i=0; i < updatedVolumeToken.length; i++) { _%>
  <%= txBuyVolumeToken[i] %> = <%= buyVolumeToken[i] %> + if targetToken == <%= i %> then buyVolume else 0 fi
  <%_ } _%>
  return <%- txBuyVolumeToken.join(", ") %>

<% const highestTouchedOrderPairs = generateTokenPairs('highestTouchedOrder', tokens) -%>
<% const highestTouchedOrderPairsArgument = highestTouchedOrderPairs.map(function(pair) {return pair.name}).join(', ') -%>
def updateHighestTouchedOrder(<%= highestTouchedOrderPairsArgument %>, sourceToken, targetToken, limit, volume):

  highestTouchedOrder = findPairInTokenPairList(<%= highestTouchedOrderPairsArgument %>, sourceToken, targetToken)

  shouldUpdate = if 0 < volume then 1 else 0 fi
  shouldUpdate = if highestTouchedOrder < limit then shouldUpdate else 0 fi

  <%_ for(var i=0; i < highestTouchedOrderPairs.length; i++) { _%>
  <%_ let pair = highestTouchedOrderPairs[i]; _%>
  <%= pair.name %> = if shouldUpdate == 1 then if sourceToken == <%= pair.source %> then if targetToken == <%= pair.target %> then limit else <%= pair.name %> fi else <%= pair.name %> fi else <%= pair.name %> fi
  <%_ } _%>

  return <%= highestTouchedOrderPairsArgument %>

def verifyCompletelyFulfilledIfLimitLowerHighestTouchedOrder(<%= highestTouchedOrderPairsArgument %>, sourceAmount, sourceToken, targetToken, limit, volume):

  highestTouchedOrder = findPairInTokenPairList(<%= highestTouchedOrderPairsArgument %>, sourceToken, targetToken)

  valid = if limit < highestTouchedOrder then 1 - (sourceAmount - volume) else 1 fi
  return valid

def checkConstraints(<%- decodedOrderTuples.join(", ") %>, <%- volumes.join(", ") %>, <%- prices.join(", ") %>):
  // volumes are not larger than in original offer
  <%_ for(var i=0; i < volumes.length; i++) { _%>
  valid = if <%- decodedOrderTuples[i].split(", ")[0] %> < <%- volumes[i] %> then 0 else 1 fi
  valid == 1
  <%_ } _%>

  // orders are only touched, if the limit price is below the calculated price:
  <%_ for(var i=0; i < volumes.length; i++) { _%>
  valid = if <%- volumes[i] %> == 0 then 1 else limitLessThanPrice(<%- decodedOrderTuples[i].split(", ").slice(1).join(', ') %>, <%- prices.join(", ") %>) fi
  valid == 1
  <%_ } _%>

  // the amount of sell volume for a token equals its buy volume:
  <%= buyVolumeToken.join(', ') %> = tupleForTokensWithValue(0)
  <%= sellVolumeToken.join(', ') %> = tupleForTokensWithValue(0)
  <%_ for(var i=0; i < volumes.length; i++) { %>
  <%_ let orderParts = decodedOrderTuples[i].split(", ") _%>
  <%= buyVolumeToken.join(', ') %> = addBuyVolumesForOrder(<%= buyVolumeToken.join(', ') %>, <%= orderParts[1] %>, <%= volumes[i] %>, <%= orderParts[2] %>, <%- prices.join(", ") %>)
  <%= sellVolumeToken.join(', ') %> = addSellVolumesForOrder(<%= sellVolumeToken.join(', ') %>, <%= orderParts[1] %>, <%= volumes[i] %>)
  <%_ } _%>

  <%_ for(var i=0; i < buyVolumeToken.length; i++) { _%>
  <%= buyVolumeToken[i] %> == <%= sellVolumeToken[i] %>
  <%_ } _%>

  // If an order σ ∈ Oi→j with a limit price p has a positive trading volume, then every order in Oi→j with a lower limit price should be completely fulfilled.
  <%= highestTouchedOrderPairsArgument %> = tupleForTokenPairsWithValue(0)
  <%_ for(var i=0; i < decodedOrderTuples.length; i++) { _%>
  <%_ let orderParts = decodedOrderTuples[i].split(", ") _%>
  <%= highestTouchedOrderPairsArgument  %> = updateHighestTouchedOrder(<%= highestTouchedOrderPairsArgument %>, <%= orderParts[1] %>, <%= orderParts[2] %>, <%= orderParts[3] %>, <%= volumes[i] %>)
  <%_ } _%>

  <%_ for(var i=0; i < decodedOrderTuples.length; i++) { _%>
  valid = verifyCompletelyFulfilledIfLimitLowerHighestTouchedOrder(<%= highestTouchedOrderPairsArgument %>, <%= decodedOrderTuples[i] %>, <%= volumes[i] %>)
  valid == 1
  <%_ } _%>

  return 1 // Could return total volume to maximize for

<% const bitwiseOrders = generateBitwiseVariables('order', 253, orders) -%>
<% const bitmap = generateVariableNames('bitmapOrder', orders) -%>
def main(<%- bitwiseOrders.join(", ") %>, <%- bitmap.join(", ") %>, <%- volumes.join(", ") %>, <%- prices.join(", ") %>):
  // Decode orders
  <%_ for(var i=0; i < bitmap.length; i++) { _%>
  <%= decodedOrderTuples[i] %> = decodeOrderBitwise(<%= bitwiseOrders.slice(i*253, (i+1)*253).join(", ") %>)
  <%_ } _%>

  // check double signatures
  <%_ for(var i=0; i < bitmap.length; i++) { _%>
    <%_ let orderParts = decodedOrderTuples[i].split(", ") _%>
    <%_ for(var part=0; part < orderParts.length; part++) { _%>
  <%= orderParts[part] %> = if <%= bitmap[i] %> == 1 then <%= orderParts[part] %> else 0 fi
    <%_ } _%>  

  <%_ } _%>
  return checkConstraints(<%- decodedOrderTuples.join(", ") %>, <%- volumes.join(", ") %>, <%- prices.join(", ") %>)